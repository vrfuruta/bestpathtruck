# -*- coding: utf-8 -*-
"""shortestpathtruck.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j1cDGqm7XEfdJzYdiOgFHYnbTboBSmzi
"""

import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display
from functools import partial

import urllib.request
url = 'https://raw.githubusercontent.com/giu-garrido/graph-caminhao/refs/heads/main/teste.txt'
response = urllib.request.urlopen(url)
content = response.read().decode('utf-8')
print(content)

data = content.split()
print(data)

def leitura(data, index):

  N, M, S = int(data[index]), int(data[index+1]), int(data[index+2]) # Salva em N = número de nodes, M = número de arestas e S = número de sedes
  index += 3 # Atualiza o index para depois dessas informações

  bridges = []
  for _ in range(M): # Percorre o número de pontes
    A, B, P = int(data[index]), int(data[index+1]), int(data[index+2]) # Salva em A = início, B = destino e P = weight (peso) da aresta
    index += 3 # Vai pra próxima aresta
    bridges.append((A, B, P))

  hq = []
  for _ in range(S): # Percorre o número de sedes
    A, B = int(data[index]), int(data[index+1]) # Salva em A = início, B = destino do caso teste
    index += 2 # Vai pra próxima sede
    hq.append((A, B))

  return N, M, S, bridges, hq, index

def criarGrafo(N, bridges):
  G = nx.Graph() # Cria o grafo

  for i in range(0, (N)): # Adiciona os nodes
    G.add_node(i+1)

  G.add_weighted_edges_from(bridges) # Adiciona as arestas com peso da lista pontes

  pos = nx.spring_layout(G, seed = 1) # Salva as posições do grafo no fromato spring, com uma seed para replicação

  labels = {(A, B): P for A, B, P in bridges} # Põe no formato com peso

  return G, labels, pos

def encontrarAGM(bridges, G):
  bridges.sort(key=lambda x: x[2], reverse=True) # Organiza a lista para maior peso -> menor peso

  T = nx.maximum_spanning_tree(G, weight='weight', algorithm='prim', ignore_nan=False) # Pega a árvore geradora máxima de G e salva em T
  aux = list(T.edges(data=True))
  l_p = dict()
  for a,b,p in aux: # Transforma para o formato necessário
    w=p['weight']
    k=(a,b)
    l_p[k]=w

  return l_p, T

def caminho(T, hq):

  for a,b in hq:
    path = nx.shortest_path(T, a, b) # Menor caminho da AGM

    aux = np.inf # Começa com infinito
    for i in range(len(path)-1):
      weights = T.get_edge_data(path[i], path[i+1])
      if weights.get('weight') < aux:
        aux = weights.get('weight') # Menor peso do caminho

    print(f'O maior peso que ele consegue carregar entre',{a}, 'e' ,{b}, 'é:',{aux})
  return path, aux

def printarGrafo(G, T, l_p,labels, pos, path):

  nx.draw(G, pos, with_labels=True, node_color="#f9b9ff", edge_color="gray", node_size=1000, font_size=15)
  nx.draw(T, pos, with_labels=True, node_color="#f9b9ff", edge_color="#75067F", node_size=1000, font_size=15)
  nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_color= "gray", font_size=10)
  nx.draw_networkx_edge_labels(G, pos, edge_labels=l_p, font_color= "#75067F", font_size=10)

  for i in range(len(path)-1): # "Grifa" o caminho do caminhão
      nx.draw_networkx_edges(T, pos, [(path[i], path[i+1])], width=10, edge_color= "#EFC3CA", alpha = 0.5)

  plt.show()

def on_button_clicked(b): # Função para quando o botão é clicado
    global index, output

    with output:
      output.clear_output(wait=True)  # Limpa o que já estava desenhado

    if index >= len(data):
        print("Todos os casos já foram exibidos.")
        return

    N, M, S, bridges, hq, new_index = leitura(data, index) # Le próximo caso
    index = new_index

    G, labels, pos = criarGrafo(N, bridges)

    opcoes = [] # Cria as opções pra escolher o caminho
    for i in hq:
        opcao = str(i[0]) + ' - ' + str(i[1])
        opcoes.append(opcao)

    a = widgets.RadioButtons( # Cria os botões dos caminhos
                options=opcoes,
                description='Caminhos:',
                disabled=False
            )

    handler_com_nome = partial(qualquer_funcao, grafo=G, bridges=bridges, pos = pos, labels = labels)

    a.observe(handler_com_nome, names='label')
    display(a)

index = 0
output = widgets.Output() # Pra mostrar as opções de caminho
path_output = widgets.Output() # Pra mostrar o grafo

display(output)
display(path_output)

def qualquer_funcao(change, grafo, bridges, pos, labels): # Função para quando escolher um caminho

  with path_output:
    path_output.clear_output(wait=True)

    origem, destino = map(int, change['new'].split(' - '))
    l_p, T = encontrarAGM(bridges, grafo)
    path,_ = caminho(T, [(origem, destino)])
    printarGrafo(grafo, T, l_p, labels, pos, path)

button = widgets.Button( # Cria o botão de próximo caso
    description='Próximo Caso',
    disabled=False,
    button_style='info',
    tooltip='Carregar o próximo caso',
    icon=''
)

button.on_click(on_button_clicked)
display(button)

on_button_clicked(None) # Carrega o primeiro caso automaticamente

